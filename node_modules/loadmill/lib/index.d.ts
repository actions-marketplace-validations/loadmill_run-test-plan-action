import './polyfills';
export = Loadmill;
declare function Loadmill(options: Loadmill.LoadmillOptions): {
    run(config: any, paramsOrCallback?: Loadmill.ParamsOrCallback, callback?: Loadmill.Callback): Promise<string>;
    runFolder(folderPath: string, paramsOrCallback?: Loadmill.ParamsOrCallback, callback?: Loadmill.Callback): Promise<Loadmill.TestResult[]>;
    wait(testDefOrId: string | Loadmill.TestDef, callback?: Loadmill.Callback): Promise<Loadmill.TestResult>;
    runTestSuite(suite: Loadmill.TestSuiteDef, paramsOrCallback?: Loadmill.ParamsOrCallback, callback?: Loadmill.Callback): Promise<Loadmill.TestDef>;
    runTestPlan(testPlan: Loadmill.TestPlanDef, params: Loadmill.Params): Promise<Loadmill.TestDef | undefined>;
    junitReport(testResult: Loadmill.TestResult | Loadmill.TestResult[], path?: string | undefined): Promise<void>;
    mochawesomeReport(testResult: Loadmill.TestResult | Loadmill.TestResult[], path?: string | undefined): Promise<void>;
};
declare namespace Loadmill {
    interface LoadmillOptions {
        token: string;
    }
    interface TestDef {
        id: string;
        type: string;
    }
    interface TestSuiteDef {
        id: string;
        description?: string;
        options?: TestSuiteOptions;
    }
    interface TestPlanDef {
        id: string;
        description?: string;
        options?: TestPlanOptions;
    }
    interface TestSuiteOptions {
        additionalDescription?: string;
        labels?: string[] | null;
        failGracefully?: boolean;
        pool?: string;
    }
    interface TestPlanOptions {
        additionalDescription?: string;
        labels?: string[] | null;
        fetchFlowRuns?: boolean;
        pool?: string;
        parallel?: number | string;
    }
    interface TestResult extends TestDef {
        url: string;
        passed: boolean;
        description: string;
        flowRuns?: Array<FlowRun>;
        testSuitesRuns?: Array<TestResult>;
        status?: string;
        startTime: string;
        endTime: string;
    }
    interface FlowRun {
        id: string;
        status: string;
        description: string;
    }
    type Configuration = object | string | any;
    type Params = {
        [key: string]: string;
    };
    type ParamsOrCallback = Params | Callback;
    type Callback = {
        (err: Error | null, result: any): void;
    } | undefined;
    type Histogram = {
        [reason: string]: number;
    };
    type TestFailures = {
        [reason: string]: {
            [histogram: string]: Histogram;
        };
    };
    type Args = {
        verbose: boolean;
        colors?: boolean;
    };
    enum TYPES {
        LOAD = "load",
        SUITE = "test-suite",
        TEST_PLAN = "test-plan"
    }
}
