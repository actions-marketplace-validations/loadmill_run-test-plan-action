"use strict";
exports.__esModule = true;
exports.mochawesomeReport = exports.junitReport = void 0;
var tslib_1 = require("tslib");
var fs = require("fs");
var path = require("path");
var xml = require("xml");
var superagent = require("superagent");
var pLimit = require('p-limit');
var flatMap = require("lodash/flatMap");
var isEmpty = require("lodash/isEmpty");
var find = require("lodash/find");
var forEach = require("lodash/forEach");
var includes = require("lodash/includes");
var utils_1 = require("./utils");
var generateJunitJsonReport = function (testResult, token) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var flowResult, suiteResult, suites, limit, jsonResults, _a, _b;
    var _c;
    return tslib_1.__generator(this, function (_d) {
        switch (_d.label) {
            case 0:
                flowResult = function (f) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
                    var url, flowRunDetails, flowRun;
                    var _a;
                    return tslib_1.__generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                url = getFlowRunAPI(f);
                                return [4 /*yield*/, superagent.get(url).auth(token, '')];
                            case 1:
                                flowRunDetails = (_b.sent()).body;
                                flowRun = {
                                    'testcase': [{
                                            _attr: {
                                                name: f.description,
                                                status: f.status,
                                                time: ((+flowRunDetails.endTime - +flowRunDetails.startTime) || 0) / 1000
                                            }
                                        }]
                                };
                                if (f.status === "FAILED") {
                                    (_a = flowRun.testcase).push.apply(_a, toFailedJUnitFlowRunReport(flowRunDetails));
                                }
                                return [2 /*return*/, flowRun];
                        }
                    });
                }); };
                suiteResult = function (suite) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
                    var _a, flowRuns, failures, limit, _b, _c;
                    var _d;
                    return tslib_1.__generator(this, function (_e) {
                        switch (_e.label) {
                            case 0:
                                _a = suite.flowRuns, flowRuns = _a === void 0 ? [] : _a;
                                failures = flowRuns.filter(function (f) { return f.status !== 'PASSED'; }).length;
                                limit = pLimit(3);
                                _d = {};
                                _b = 'testsuite';
                                _c = [[{
                                            _attr: {
                                                name: suite.description,
                                                errors: failures,
                                                failures: failures,
                                                timestamp: (new Date()).toISOString().slice(0, -5),
                                                tests: flowRuns.length,
                                                url: suite.url
                                            }
                                        }]];
                                return [4 /*yield*/, Promise.all(flowRuns.map(function (f) { return limit(function () { return flowResult(f); }); }))];
                            case 1: return [2 /*return*/, (_d[_b] = tslib_1.__spreadArray.apply(void 0, _c.concat([_e.sent()])),
                                    _d)];
                        }
                    });
                }); };
                if (!Array.isArray(testResult)) {
                    if (Array.isArray(testResult.testSuitesRuns)) { // testplan
                        suites = testResult.testSuitesRuns;
                    }
                    else {
                        suites = [testResult]; // single run
                    }
                }
                else {
                    suites = testResult; // multiple suites
                }
                limit = pLimit(3);
                _c = {};
                _a = 'testsuites';
                _b = [[{
                            _attr: {
                                name: 'Loadmill suites run'
                            }
                        }]];
                return [4 /*yield*/, Promise.all(suites.map(function (s) { return limit(function () { return suiteResult(s); }); }))];
            case 1:
                jsonResults = (_c[_a] = tslib_1.__spreadArray.apply(void 0, _b.concat([_d.sent()])),
                    _c);
                return [2 /*return*/, jsonResults];
        }
    });
}); };
var ensureDirectoryExistence = function (filePath) {
    var dirname = path.dirname(filePath);
    if (fs.existsSync(dirname)) {
        return true;
    }
    ensureDirectoryExistence(dirname);
    fs.mkdirSync(dirname);
};
var resolvePath = function (path, suffix) {
    if (path.charAt(path.length - 1) == '/') {
        path = path.substr(0, path.length - 1);
    }
    return path + "/loadmill/results." + suffix;
};
var toFailedJUnitFlowRunReport = function (flowRun) {
    var errs = toFailedFlowRunReport(flowRun, function (check, operation, value, actual) {
        var text = '';
        if (actual != null) {
            text += "Expected: " + check + " " + operation + " " + (value != null ? value : '') + " ";
            text += "Actual: " + (actual !== 'null' ? actual : 'null') + " ";
        }
        return text;
    });
    return errs.map(function (e) { return ({
        'failure': [{
                _attr: {
                    message: e.desc + " " + (e.ass ? e.ass : ''),
                    type: 'ERROR'
                }
            }]
    }); });
};
// TODO this all flow should come from @loadmill package
var toFailedFlowRunReport = function (flowRun, formater) {
    var errs = [];
    var _a = flowRun.result, resolvedRequests = _a.resolvedRequests, failures = _a.failures, err = _a.err;
    if (Array.isArray(resolvedRequests) && resolvedRequests.length > 0) {
        resolvedRequests.map(function (req, i) {
            var description = req.description, method = req.method, url = req.url, _a = req.assert, assert = _a === void 0 ? [] : _a;
            var postParameters = flowRun.redactableResult && flowRun.redactableResult[i].postParameters;
            var reqFailures = failures && failures[i];
            var numSuccesses = 1;
            var _b = reqFailures || {}, _c = _b.histogram, histogram = _c === void 0 ? {} : _c, _d = _b.numFailures, numFailures = _d === void 0 ? 0 : _d;
            var totalNumRequests = numSuccesses + numFailures;
            if (numFailures > 0) {
                var flowFailedText_1 = genReqDesc(i) + " " + (description ? genReqDesc(i, description) : '') + " " + method + " " + url + " =>";
                var assertionNames_1 = Object.keys(assert);
                var requestErrorNames = Object.keys(histogram).filter(function (name) { return !includes(assertionNames_1, name); });
                requestErrorNames.map(function (name) {
                    flowFailedText_1 += " " + name + " ";
                });
                var flatPostParameters_1 = flatMap(postParameters);
                var assertionItems = getItems(assertionNames_1, histogram, totalNumRequests);
                forEach(assertionItems, function (assertion) {
                    if (assert[assertion.name]) {
                        var check = assert[assertion.name].check;
                        var actual = getActualValue(assertion.errorRate, flatPostParameters_1, check);
                        if (actual) {
                            var assErr = generateAssertionName(assert[assertion.name], actual, formater);
                            errs.push({ desc: flowFailedText_1, ass: assErr });
                        }
                    }
                });
                if (isEmpty(errs)) {
                    errs.push({ desc: flowFailedText_1 });
                }
            }
        });
    }
    else if (err) {
        errs.push({ desc: typeof err === 'string' ? err : err.message });
    }
    return errs;
};
function generateAssertionName(_a, actual, formatAssertion) {
    var check = _a.check, equals = _a.equals, notEquals = _a.notEquals, contains = _a.contains, notContains = _a.notContains, matches = _a.matches, falsy = _a.falsy, greater = _a.greater, lesser = _a.lesser, JSONSchema = _a.JSONSchema;
    if (equals != null) {
        return formatAssertion(check, 'Equals', equals, actual);
    }
    else if (notEquals != null) {
        return formatAssertion(check, 'Doesn\'t equal', notEquals, actual);
    }
    else if (contains != null) {
        return formatAssertion(check, 'Contains', contains, actual);
    }
    else if (notContains != null) {
        return formatAssertion(check, 'Doesn\'t contain', notContains, actual);
    }
    else if (matches != null) {
        return formatAssertion(check, 'Matches', matches, actual);
    }
    else if (greater != null) {
        return formatAssertion(check, 'Greater than', greater, actual);
    }
    else if (lesser != null) {
        return formatAssertion(check, 'Less than', lesser, actual);
    }
    else if (falsy != null) {
        return formatAssertion(check, 'Doesn\'t exist', null, actual);
    }
    else if (JSONSchema != null) {
        return formatAssertion(check, 'JSON Schema', JSONSchema, actual);
    }
    else {
        return formatAssertion(check, 'Exists', null, actual);
    }
}
/**
 * null - we dont want to show actual value - load test or successfull test.
 * NULL_VAL - we want to show there was a null value.
 * else - show the actual value.
 */
function getActualValue(errorRate, postParameters, check) {
    if (errorRate && !isEmpty(postParameters)) {
        // empty means load test
        var exists = find(postParameters, function (p) { return p[check]; });
        return exists ? exists[check] : 'null';
    }
    return null;
}
function getItems(names, histogram, totalNumRequests) {
    var items = names.sort().map(function (name) {
        var numFailures = histogram[name];
        var errorRate = calculateErrorRate(numFailures, totalNumRequests - numFailures);
        return { name: name, errorRate: errorRate };
    });
    return isEmpty(items) ? [{ name: 'None', errorRate: 0 }] : items;
}
function calculateErrorRate(failures, successes) {
    failures = numberify(failures);
    successes = numberify(successes);
    if (failures === 0) {
        return 0;
    }
    else if (successes === 0) {
        return 1;
    }
    else {
        return failures / (failures + successes);
    }
}
function numberify(num, defaultValue) {
    if (defaultValue === void 0) { defaultValue = 0; }
    if (num == null) {
        return defaultValue;
    }
    else {
        return Number(num);
    }
}
function genReqDesc(index, description) {
    return (description ? description : "Request #" + (index + 1)) + " -";
}
function getFlowRunAPI(f) {
    var testingServer = "https://" + utils_1.TESTING_HOST;
    return testingServer + "/api/test-suites-runs/flows/" + f.id;
}
function getFlowRunWebURL(s, f) {
    var testingServer = "https://" + utils_1.TESTING_HOST;
    return testingServer + "/app/api-tests/test-suite-runs/" + s.id + "/flows/" + f.id;
}
var toMochawesomeFailedFlow = function (flowRun) {
    var _a;
    var errs = toFailedFlowRunReport(flowRun, function (check, operation, value, actual) {
        var text = '';
        if (actual != null) {
            text += "\n+   \"Expected: " + check + " " + operation + " " + (value != null ? value : '') + " ";
            text += "\n-   \"Actual: " + (actual !== 'null' ? actual : 'null') + " ";
        }
        return text;
    });
    return {
        "showDiff": true,
        "actual": "",
        "negate": false,
        "_message": "",
        "generatedMessage": false,
        "diff": ((_a = errs[0]) === null || _a === void 0 ? void 0 : _a.desc) + errs.reduce(function (acc, e) { return acc + " \n " + (e.ass ? "\n " + e.ass : ''); }, '')
    };
};
var flowToMochawesone = function (suite, flow, token) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var url, flowData, hasPassed, hasFailed, res;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                url = getFlowRunAPI(flow);
                return [4 /*yield*/, superagent.get(url).auth(token, '')];
            case 1:
                flowData = (_a.sent()).body;
                hasPassed = flow.status === 'PASSED';
                hasFailed = flow.status === 'FAILED';
                res = {
                    "title": flow.description,
                    "fullTitle": flow.description,
                    "timedOut": false,
                    "duration": (flowData.endTime - flowData.startTime) || 0,
                    "state": hasPassed ? 'passed' : 'failed',
                    "pass": hasPassed,
                    "fail": hasFailed,
                    "isHook": false,
                    "skipped": false,
                    "pending": false,
                    "code": getFlowRunWebURL(suite, flow),
                    "err": hasFailed ? toMochawesomeFailedFlow(flowData) : {},
                    "uuid": flow.id
                };
                return [2 /*return*/, res];
        }
    });
}); };
var suiteToMochawesone = function (suite, token) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var flows, passedFlows, failedFlows, limit, _a;
    var _b;
    return tslib_1.__generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                flows = suite.flowRuns || [];
                passedFlows = flows.filter(function (f) { return f.status === 'PASSED'; }).map(function (f) { return f.id; });
                failedFlows = flows.filter(function (f) { return f.status === 'FAILED'; }).map(function (f) { return f.id; });
                limit = pLimit(3);
                _b = {
                    "title": suite.description
                };
                _a = "tests";
                return [4 /*yield*/, Promise.all(flows.filter(function (flow) { return ['PASSED', 'FAILED'].includes(flow.status); })
                        .map(function (f) { return limit(function () { return flowToMochawesone(suite, f, token); }); }))];
            case 1: return [2 /*return*/, (_b[_a] = _c.sent(),
                    _b["duration"] = ((+suite.endTime || Date.now()) - +suite.startTime),
                    _b["suites"] = [],
                    _b["uuid"] = suite.id,
                    _b["passes"] = passedFlows,
                    _b["failures"] = failedFlows,
                    _b["root"] = false,
                    _b["_timeout"] = 0,
                    _b["file"] = "",
                    _b["fullFile"] = "",
                    _b["beforeHooks"] = [],
                    _b["afterHooks"] = [],
                    _b["skipped"] = [],
                    _b["pending"] = [],
                    _b)];
        }
    });
}); };
var generateMochawesomeReport = function (testResult, token) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var suites, passedSuites, failedSuites, duration, suitesLength, limit, res, _a, _b;
    var _c, _d;
    return tslib_1.__generator(this, function (_e) {
        switch (_e.label) {
            case 0:
                suites = !Array.isArray(testResult) ? (testResult.testSuitesRuns || [testResult]) : testResult;
                passedSuites = suites.filter(function (t) { return t.passed; }).length;
                failedSuites = suites.filter(function (t) { return !t.passed; }).length;
                duration = suites.reduce(function (acc, s) { return acc + ((+s.endTime || Date.now()) - +s.startTime); }, 0);
                suitesLength = suites.length;
                limit = pLimit(3);
                _c = {
                    "stats": {
                        "suites": suitesLength,
                        "tests": suitesLength,
                        "passes": passedSuites,
                        "failures": failedSuites,
                        "start": (suites[0] ? getFirstExecutedSuiteTime(suites) : new Date()).toISOString(),
                        "end": new Date().toISOString(),
                        "pending": 0,
                        "testsRegistered": suitesLength,
                        "pendingPercent": 0,
                        "passPercent": suitesLength == 0 ? 0 : (passedSuites / suitesLength) * 100,
                        "other": 0,
                        "hasOther": false,
                        "skipped": 0,
                        "hasSkipped": false,
                        "duration": duration
                    }
                };
                _a = "results";
                _d = {
                    "title": "Loadmill API tests"
                };
                _b = "suites";
                return [4 /*yield*/, Promise.all(suites.map(function (s) { return limit(function () { return suiteToMochawesone(s, token); }); }))];
            case 1:
                res = (_c[_a] = [
                    (_d[_b] = _e.sent(),
                        _d["tests"] = [],
                        _d["pending"] = [],
                        _d["root"] = true,
                        _d["_timeout"] = 0,
                        _d["uuid"] = suites[0] ? suites[0].id : '123e4567-e89b-12d3-a456-426652340000',
                        _d["beforeHooks"] = [],
                        _d["afterHooks"] = [],
                        _d["fullFile"] = "",
                        _d["file"] = "",
                        _d["passes"] = [],
                        _d["failures"] = [],
                        _d["skipped"] = [],
                        _d["duration"] = duration,
                        _d["rootEmpty"] = true,
                        _d)
                ],
                    _c);
                return [2 /*return*/, res];
        }
    });
}); };
var junitReport = function (testResult, token, path) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var jsonResults, asXml, resolvedPath;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (!testResult) {
                    return [2 /*return*/];
                }
                return [4 /*yield*/, generateJunitJsonReport(testResult, token)];
            case 1:
                jsonResults = _a.sent();
                asXml = xml(jsonResults, { indent: '  ', declaration: true });
                resolvedPath = resolvePath(path ? path : './test-results', 'xml');
                ensureDirectoryExistence(resolvedPath);
                fs.writeFileSync(resolvedPath, asXml);
                return [2 /*return*/];
        }
    });
}); };
exports.junitReport = junitReport;
var mochawesomeReport = function (testResult, token, path) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var jsonResults, resolvedPath;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (!testResult) {
                    return [2 /*return*/];
                }
                return [4 /*yield*/, generateMochawesomeReport(testResult, token)];
            case 1:
                jsonResults = _a.sent();
                resolvedPath = resolvePath(path ? path : './mochawesome-results', 'json');
                ensureDirectoryExistence(resolvedPath);
                fs.writeFileSync(resolvedPath, JSON.stringify(jsonResults, null, 2));
                return [2 /*return*/];
        }
    });
}); };
exports.mochawesomeReport = mochawesomeReport;
function getFirstExecutedSuiteTime(suites) {
    var firstSuite = suites.reduce(function (prev, curr) {
        return prev.startTime < curr.startTime ? prev : curr;
    });
    return new Date(firstSuite.startTime);
}
